<?xml version="1.0" encoding="UTF-8"?>
<rss xmlns:atom="http://www.w3.org/2005/Atom" xmlns:media="http://search.yahoo.com/mrss/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:distill="https://distill.pub/journal/" version="2.0">
  <channel>
    <title>R some blog</title>
    <link>https://rpahl.github.io/r-some-blog/</link>
    <atom:link href="https://rpahl.github.io/r-some-blog/index.xml" rel="self" type="application/rss+xml"/>
    <description>Some hopefully useful (or even awesome) stuff related to R programming.
</description>
    <image>
      <title>R some blog</title>
      <url>https://rpahl.github.io/r-some-blog/images/meatwork-toon-close.jpg</url>
      <link>https://rpahl.github.io/r-some-blog/</link>
    </image>
    <generator>Distill</generator>
    <lastBuildDate>Fri, 17 Dec 2021 00:00:00 +0000</lastBuildDate>
    <item>
      <title>container: v1.0.0 on CRAN</title>
      <link>https://rpahl.github.io/r-some-blog/posts/container1.0</link>
      <description>
The update contains some breaking changes and brings a lot of new features
and operators, which markedly improves using containers in both
interactive R sessions and code development.
Also there is a new class dict.table to support the data.table package.



&lt;h3 id="what-is-container"&gt;What is &lt;code&gt;container&lt;/code&gt;?&lt;/h3&gt;
&lt;div&gt;
&lt;p&gt;A container can be considered as an enhanced version of base R’s list with a carefully designed set of extract, replace, and remove operations. They enable an easier and safer way to work with list-like data structures in interactive R sessions and in particular when developing critical code.&lt;/p&gt;
&lt;/div&gt;
&lt;aside&gt;
&lt;p&gt;&lt;img src="https://rpahl.github.io/r-some-blog/posts/container1.0/container.png" width="100%" /&gt;&lt;/p&gt;
&lt;/aside&gt;
&lt;p&gt;This blog post can only provide a glimpse of all the things you can do with containers so here the focus is on some features suitable for &lt;em&gt;interactive&lt;/em&gt; R sessions.&lt;/p&gt;
&lt;h3 id="print"&gt;Print&lt;/h3&gt;
&lt;pre class="r"&gt;&lt;code&gt;library(container)

co &amp;lt;- container(colors = c(&amp;quot;Red&amp;quot;, &amp;quot;Green&amp;quot;, &amp;quot;Blue&amp;quot;),
                numbers = 1:10,
                data = cars[1:10, ])&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Let’s start by comparing the print output of container and list (click on the panels below).&lt;/p&gt;
&lt;div class="panelset"&gt;
&lt;div id="container" class="container-out panel"&gt;
&lt;h3 class="container-out"&gt;container&lt;/h3&gt;
&lt;pre class="r"&gt;&lt;code&gt;print(co)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;[colors = (&amp;quot;Red&amp;quot; &amp;quot;Green&amp;quot; &amp;quot;Blue&amp;quot;), numbers = (1L 2L 3L 4L ...),
 data = &amp;lt;&amp;lt;data.frame(10x2)&amp;gt;&amp;gt;]&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id="list" class="list-out panel"&gt;
&lt;h3 class="list-out"&gt;list&lt;/h3&gt;
&lt;pre class="r"&gt;&lt;code&gt;li = as.list(co)
print(li)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;$colors
[1] &amp;quot;Red&amp;quot;   &amp;quot;Green&amp;quot; &amp;quot;Blue&amp;quot; 

$numbers
 [1]  1  2  3  4  5  6  7  8  9 10

$data
   speed dist
1      4    2
2      4   10
3      7    4
4      7   22
5      8   16
6      9   10
7     10   18
8     10   26
9     10   34
10    11   17&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;As you can see the container by default prints very compact. Next, take a look at data extraction.&lt;/p&gt;
&lt;h3 id="extract"&gt;Extract&lt;/h3&gt;
&lt;p&gt;A container provides all familiar extract operations known from base R lists but also some new operations to make life (hopefully) easier. In contrast to base R lists, undefined indices are ignored and thus do not produce &lt;code&gt;NULL&lt;/code&gt; values.&lt;/p&gt;
&lt;div class="panelset"&gt;
&lt;div id="container-1" class="container-out panel"&gt;
&lt;h3 class="container-out"&gt;container&lt;/h3&gt;
&lt;pre class="r"&gt;&lt;code&gt;co[[1]]                  # standard&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;[1] &amp;quot;Red&amp;quot;   &amp;quot;Green&amp;quot; &amp;quot;Blue&amp;quot; &lt;/code&gt;&lt;/pre&gt;
&lt;pre class="r"&gt;&lt;code&gt;co[2:3]                  # standard&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;[numbers = (1L 2L 3L 4L ...), data = &amp;lt;&amp;lt;data.frame(10x2)&amp;gt;&amp;gt;]&lt;/code&gt;&lt;/pre&gt;
&lt;pre class="r"&gt;&lt;code&gt;co[c(1:2, 5:8)]          # ignore undefined indices&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;[colors = (&amp;quot;Red&amp;quot; &amp;quot;Green&amp;quot; &amp;quot;Blue&amp;quot;), numbers = (1L 2L 3L 4L ...)]&lt;/code&gt;&lt;/pre&gt;
&lt;pre class="r"&gt;&lt;code&gt;co[1, 2, 5:8]            # pass any number of indices - same as before&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;[colors = (&amp;quot;Red&amp;quot; &amp;quot;Green&amp;quot; &amp;quot;Blue&amp;quot;), numbers = (1L 2L 3L 4L ...)]&lt;/code&gt;&lt;/pre&gt;
&lt;pre class="r"&gt;&lt;code&gt;co[1, &amp;quot;data&amp;quot;, 2, &amp;quot;foo&amp;quot;]  # index types can be mixed&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;[colors = (&amp;quot;Red&amp;quot; &amp;quot;Green&amp;quot; &amp;quot;Blue&amp;quot;), data = &amp;lt;&amp;lt;data.frame(10x2)&amp;gt;&amp;gt;,
 numbers = (1L 2L 3L 4L ...)]&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id="list-1" class="list-out panel"&gt;
&lt;h3 class="list-out"&gt;list&lt;/h3&gt;
&lt;pre class="r"&gt;&lt;code&gt;li[[1]]                  # standard&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;[1] &amp;quot;Red&amp;quot;   &amp;quot;Green&amp;quot; &amp;quot;Blue&amp;quot; &lt;/code&gt;&lt;/pre&gt;
&lt;pre class="r"&gt;&lt;code&gt;li[2:3]                  # standard&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;$numbers
 [1]  1  2  3  4  5  6  7  8  9 10

$data
   speed dist
1      4    2
2      4   10
3      7    4
4      7   22
5      8   16
6      9   10
7     10   18
8     10   26
9     10   34
10    11   17&lt;/code&gt;&lt;/pre&gt;
&lt;pre class="r"&gt;&lt;code&gt;li[c(1:2, 5:8)]          # pad NULLs for undefined indices&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;$colors
[1] &amp;quot;Red&amp;quot;   &amp;quot;Green&amp;quot; &amp;quot;Blue&amp;quot; 

$numbers
 [1]  1  2  3  4  5  6  7  8  9 10

$&amp;lt;NA&amp;gt;
NULL

$&amp;lt;NA&amp;gt;
NULL

$&amp;lt;NA&amp;gt;
NULL

$&amp;lt;NA&amp;gt;
NULL&lt;/code&gt;&lt;/pre&gt;
&lt;pre class="r"&gt;&lt;code&gt;li[1, 2, 5:8]            # not supported&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;Error in li[1, 2, 5:8]: incorrect number of dimensions&lt;/code&gt;&lt;/pre&gt;
&lt;pre class="r"&gt;&lt;code&gt;li[1, &amp;quot;data&amp;quot;, 2, &amp;quot;foo&amp;quot;]  # not supported&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;Error in li[1, &amp;quot;data&amp;quot;, 2, &amp;quot;foo&amp;quot;]: incorrect number of dimensions&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h3 id="replace"&gt;Replace&lt;/h3&gt;
&lt;p&gt;In the same way, a container provides both familiar and new operations for interactive element replacement.&lt;/p&gt;
&lt;div class="panelset"&gt;
&lt;div id="container-2" class="container-out panel"&gt;
&lt;h3 class="container-out"&gt;container&lt;/h3&gt;
&lt;pre class="r"&gt;&lt;code&gt;co[2:3] &amp;lt;- NA                                # standard
co&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;[colors = (&amp;quot;Red&amp;quot; &amp;quot;Green&amp;quot; &amp;quot;Blue&amp;quot;), numbers = NA, data = NA]&lt;/code&gt;&lt;/pre&gt;
&lt;pre class="r"&gt;&lt;code&gt;co[[1]] &amp;lt;- &amp;quot;&amp;quot;                                # standard
co&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;[colors = &amp;quot;&amp;quot;, numbers = NA, data = NA]&lt;/code&gt;&lt;/pre&gt;
&lt;pre class="r"&gt;&lt;code&gt;co[[&amp;quot;colors&amp;quot;]] &amp;lt;- &amp;quot;red&amp;quot;                      # standard
co&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;[colors = &amp;quot;red&amp;quot;, numbers = NA, data = NA]&lt;/code&gt;&lt;/pre&gt;
&lt;pre class="r"&gt;&lt;code&gt;co[list(&amp;quot;colors&amp;quot;, 2)] &amp;lt;- list(&amp;quot;blue&amp;quot;, 1:4)   # mixed indices
co&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;[colors = &amp;quot;blue&amp;quot;, numbers = (1L 2L 3L 4L), data = NA]&lt;/code&gt;&lt;/pre&gt;
&lt;pre class="r"&gt;&lt;code&gt;co[[{&amp;quot;blue&amp;quot;}]] &amp;lt;- &amp;quot;green&amp;quot;                    # replace by value
co&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;[colors = &amp;quot;green&amp;quot;, numbers = (1L 2L 3L 4L), data = NA]&lt;/code&gt;&lt;/pre&gt;
&lt;pre class="r"&gt;&lt;code&gt;co[[{NA}]] &amp;lt;- 0                              # replace by value
co&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;[colors = &amp;quot;green&amp;quot;, numbers = (1L 2L 3L 4L), data = 0]&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id="list-2" class="list-out panel"&gt;
&lt;h3 class="list-out"&gt;list&lt;/h3&gt;
&lt;pre class="r"&gt;&lt;code&gt;li[2:3] &amp;lt;- NA                                # standard
li&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;$colors
[1] &amp;quot;Red&amp;quot;   &amp;quot;Green&amp;quot; &amp;quot;Blue&amp;quot; 

$numbers
[1] NA

$data
[1] NA&lt;/code&gt;&lt;/pre&gt;
&lt;pre class="r"&gt;&lt;code&gt;li[[1]] &amp;lt;- &amp;quot;&amp;quot;                                # standard
li&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;$colors
[1] &amp;quot;&amp;quot;

$numbers
[1] NA

$data
[1] NA&lt;/code&gt;&lt;/pre&gt;
&lt;pre class="r"&gt;&lt;code&gt;li[[&amp;quot;colors&amp;quot;]] &amp;lt;- &amp;quot;red&amp;quot;                      # standard
co&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;[colors = &amp;quot;green&amp;quot;, numbers = (1L 2L 3L 4L), data = 0]&lt;/code&gt;&lt;/pre&gt;
&lt;pre class="r"&gt;&lt;code&gt;li[list(&amp;quot;colors&amp;quot;, 2)] &amp;lt;- list(&amp;quot;blue&amp;quot;, 1:4)   # not supported&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;Error in li[list(&amp;quot;colors&amp;quot;, 2)] &amp;lt;- list(&amp;quot;blue&amp;quot;, 1:4): invalid subscript type &amp;#39;list&amp;#39;&lt;/code&gt;&lt;/pre&gt;
&lt;pre class="r"&gt;&lt;code&gt;#li[[{&amp;quot;blue&amp;quot;}]] &amp;lt;- &amp;quot;green&amp;quot;                   # not supported

#li[[{NA}]] &amp;lt;- 0                             # not supported&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;To see the full official documentation, visit &lt;a href="https://rpahl.github.io/container/index.html"&gt;https://rpahl.github.io/container/&lt;/a&gt;.&lt;/p&gt;
&lt;pre class="r distill-force-highlighting-css"&gt;&lt;code&gt;&lt;/code&gt;&lt;/pre&gt;</description>
      <distill:md5>d7223ab21afd9229a1eb3a48f7d61da2</distill:md5>
      <category>container</category>
      <category>list</category>
      <category>R package</category>
      <guid>https://rpahl.github.io/r-some-blog/posts/container1.0</guid>
      <pubDate>Fri, 17 Dec 2021 00:00:00 +0000</pubDate>
      <media:content url="https://rpahl.github.io/r-some-blog/posts/container1.0/distill-preview.png" medium="image" type="image/png" width="602" height="415"/>
    </item>
    <item>
      <title>Why I don't use R Markdown's ref.label</title>
      <link>https://rpahl.github.io/r-some-blog/posts/ref-label</link>
      <description>
R Markdown provides the chunk option `ref.label` to 
reuse chunks. In this post, I'll show potential problems with this approach
and present an easy and safe alternative. 



&lt;p&gt;&lt;img src="https://rpahl.github.io/r-some-blog/posts/ref-label/ref-label.png" width="50%" /&gt;&lt;/p&gt;
&lt;h2 id="motivation"&gt;Motivation&lt;/h2&gt;
&lt;p&gt;Consider you have defined variable &lt;code&gt;x&lt;/code&gt;,&lt;/p&gt;
&lt;pre class="r"&gt;&lt;code&gt;x = 1&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;and define another chunk, where you simply add one up&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;```{r addOne}
sum = x + 1
sum
```&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;resulting in&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[1] 2&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;To reuse this chunk, an empty code block is created referencing the above chunk&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;```{r, ref.label = &amp;#39;addOne&amp;#39;}
```&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;again resulting in&lt;/p&gt;
&lt;pre class="r"&gt;&lt;code&gt;sum = x + 1
sum&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;[1] 2&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Behind the scenes, the chunk basically was copy-pasted and then executed again. One problem is that one can easily lose track of the scope of the variables used in that chunk. For example, let’s assume you use the &lt;code&gt;sum&lt;/code&gt; variable further below in your document to store some other result:&lt;/p&gt;
&lt;pre class="r"&gt;&lt;code&gt;sum = 10&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you now again reuse the above chunk&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;```{r, ref.label = &amp;#39;addOne&amp;#39;}
```&lt;/code&gt;&lt;/pre&gt;
&lt;pre class="r"&gt;&lt;code&gt;sum = x + 1
sum&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;[1] 2&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;sum&lt;/code&gt; has been overwritten by the chunk:&lt;/p&gt;
&lt;pre class="r"&gt;&lt;code&gt;print(sum)  # expect sum == 10&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;[1] 2&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Since the &lt;code&gt;ref.label&lt;/code&gt; chunk is empty, this issue might not be easily spotted.&lt;/p&gt;
&lt;p&gt;Another inconvenience arrises with &lt;a href="https://rstudio.com/"&gt;RStudio&lt;/a&gt;’s notebook functionality to execute individual code chunks. While the original chunk can be executed, none of the empty &lt;code&gt;ref.label&lt;/code&gt; chunks can. Funnily enough, this inconvenience was what made me think about an alternative solution.&lt;/p&gt;
&lt;h2 id="alternative-solution"&gt;Alternative solution&lt;/h2&gt;
&lt;p&gt;Luckily, the solution is quite simple - put your entire chunk inside a function and then “reference” the function:&lt;/p&gt;
&lt;pre class="r"&gt;&lt;code&gt;add1 &amp;lt;- function(x) {
    sum = x + 1
    sum
}&lt;/code&gt;&lt;/pre&gt;
&lt;pre class="r"&gt;&lt;code&gt;add1(x)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;[1] 2&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now both the &lt;code&gt;sum&lt;/code&gt; variable is perfectly scoped and the “referenced” call can be executed in the RStudio notebook as usual. Plus, of course, this “chunk” could be easily parametrized:&lt;/p&gt;
&lt;pre class="r"&gt;&lt;code&gt;addY &amp;lt;- function(x, y) {
    sum = x + y
    sum
}
addY(x, y = 1)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;[1] 2&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="summary"&gt;Summary&lt;/h2&gt;
&lt;p&gt;Downsides of using &lt;code&gt;ref.label&lt;/code&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;potential issues with (global) variables as chunk does &lt;em&gt;not&lt;/em&gt; provide local scoping&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ref.label&lt;/code&gt; chunks are empty and therefore cannot be executed in RStudio notebooks&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Proposed solution: encapsulate entire chunk inside a function and then execute the function wherever you would reference the chunk.&lt;/p&gt;
&lt;pre class="r distill-force-highlighting-css"&gt;&lt;code&gt;&lt;/code&gt;&lt;/pre&gt;</description>
      <distill:md5>ae3adb5285ae4d14aa4490b21ca5cb5d</distill:md5>
      <category>R-Markdown</category>
      <category>knitr</category>
      <guid>https://rpahl.github.io/r-some-blog/posts/ref-label</guid>
      <pubDate>Sat, 08 Aug 2020 00:00:00 +0000</pubDate>
      <media:content url="https://rpahl.github.io/r-some-blog/posts/ref-label/distill-preview.png" medium="image" type="image/png" width="279" height="117"/>
    </item>
    <item>
      <title>Quicker knitr kables in RStudio notebook</title>
      <link>https://rpahl.github.io/r-some-blog/posts/kable_if</link>
      <description>
In this post a simple RStudio hack is presented on how to display tables
produced via knitr kable efficiently in the RStudio session.



&lt;h2 id="the-setup"&gt;The setup&lt;/h2&gt;
&lt;p&gt;The &lt;a href="https://rstudio.com/"&gt;RStudio&lt;/a&gt; notebook is a great interactive tool to build a statistical report. Being able to see statistics and graphs right on the fly probably has saved me countless hours, especially when building complex reports.&lt;/p&gt;
&lt;p&gt;However, one thing that has always bothered me was the way tables are displayed in the notebook with &lt;a href="https://CRAN.R-project.org/package=knitr"&gt;knitr&lt;/a&gt;’s &lt;code&gt;kable&lt;/code&gt; function. For example, consider the &lt;code&gt;airquality&lt;/code&gt; data set:&lt;/p&gt;
&lt;pre class="r"&gt;&lt;code&gt;head(airquality)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;  Ozone Solar.R Wind Temp Month Day
1    41     190  7.4   67     5   1
2    36     118  8.0   72     5   2
3    12     149 12.6   74     5   3
4    18     313 11.5   62     5   4
5    NA      NA 14.3   56     5   5
6    28      NA 14.9   66     5   6&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;To get a nice table in your report you type&lt;/p&gt;
&lt;pre class="r"&gt;&lt;code&gt;knitr::kable(head(airquality), caption = &amp;quot;New York Air Quality Measurements.&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;which shows up nicely formatted in the final output&lt;/p&gt;
&lt;table&gt;
&lt;caption&gt;(#tab:unnamed-chunk-3)New York Air Quality Measurements.&lt;/caption&gt;
&lt;thead&gt;
&lt;tr class="header"&gt;
&lt;th align="right"&gt;Ozone&lt;/th&gt;
&lt;th align="right"&gt;Solar.R&lt;/th&gt;
&lt;th align="right"&gt;Wind&lt;/th&gt;
&lt;th align="right"&gt;Temp&lt;/th&gt;
&lt;th align="right"&gt;Month&lt;/th&gt;
&lt;th align="right"&gt;Day&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr class="odd"&gt;
&lt;td align="right"&gt;41&lt;/td&gt;
&lt;td align="right"&gt;190&lt;/td&gt;
&lt;td align="right"&gt;7.4&lt;/td&gt;
&lt;td align="right"&gt;67&lt;/td&gt;
&lt;td align="right"&gt;5&lt;/td&gt;
&lt;td align="right"&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="even"&gt;
&lt;td align="right"&gt;36&lt;/td&gt;
&lt;td align="right"&gt;118&lt;/td&gt;
&lt;td align="right"&gt;8.0&lt;/td&gt;
&lt;td align="right"&gt;72&lt;/td&gt;
&lt;td align="right"&gt;5&lt;/td&gt;
&lt;td align="right"&gt;2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="odd"&gt;
&lt;td align="right"&gt;12&lt;/td&gt;
&lt;td align="right"&gt;149&lt;/td&gt;
&lt;td align="right"&gt;12.6&lt;/td&gt;
&lt;td align="right"&gt;74&lt;/td&gt;
&lt;td align="right"&gt;5&lt;/td&gt;
&lt;td align="right"&gt;3&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="even"&gt;
&lt;td align="right"&gt;18&lt;/td&gt;
&lt;td align="right"&gt;313&lt;/td&gt;
&lt;td align="right"&gt;11.5&lt;/td&gt;
&lt;td align="right"&gt;62&lt;/td&gt;
&lt;td align="right"&gt;5&lt;/td&gt;
&lt;td align="right"&gt;4&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="odd"&gt;
&lt;td align="right"&gt;NA&lt;/td&gt;
&lt;td align="right"&gt;NA&lt;/td&gt;
&lt;td align="right"&gt;14.3&lt;/td&gt;
&lt;td align="right"&gt;56&lt;/td&gt;
&lt;td align="right"&gt;5&lt;/td&gt;
&lt;td align="right"&gt;5&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="even"&gt;
&lt;td align="right"&gt;28&lt;/td&gt;
&lt;td align="right"&gt;NA&lt;/td&gt;
&lt;td align="right"&gt;14.9&lt;/td&gt;
&lt;td align="right"&gt;66&lt;/td&gt;
&lt;td align="right"&gt;5&lt;/td&gt;
&lt;td align="right"&gt;6&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id="the-problem"&gt;The problem&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;But&lt;/em&gt; in the interactive RStudio notebook session the table looks something like the following:&lt;/p&gt;
&lt;p&gt;&lt;img src="https://rpahl.github.io/r-some-blog/posts/kable_if/kable.png" width="100%" /&gt;&lt;/p&gt;
&lt;p&gt;So first of all, the formatting is not that great. Secondly, the table chunk consumes way too much space of the notebook and, at times, can be very cumbersome to scroll. Also for bigger tables (and depending on your hardware) it can take up to a few seconds for the table to be built.&lt;/p&gt;
&lt;p&gt;So often when I was using &lt;code&gt;kable&lt;/code&gt;, I felt my workflow being disrupted. In the interactive session I want a table being built quickly and in a clean format. Now, using the simple &lt;code&gt;print&lt;/code&gt; function you’ll get exactly this&lt;/p&gt;
&lt;p&gt;&lt;img src="https://rpahl.github.io/r-some-blog/posts/kable_if/print-table.png" width="100%" /&gt;&lt;/p&gt;
&lt;p&gt;So my initial quick-and-dirty workaround during the interactive session was to comment out the &lt;code&gt;knitr&lt;/code&gt; statement and use the print function.&lt;/p&gt;
&lt;pre class="r"&gt;&lt;code&gt;#knitr::kable(head(airquality), caption = &amp;quot;New York Air Quality Measurements.&amp;quot;)
print(head(airquality))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Then, only when creating the final report, I would comment out the &lt;code&gt;print&lt;/code&gt; function and use &lt;code&gt;kable&lt;/code&gt; again. Of course, there is a much more elegant and easier solution to get this without having to switch between functions.&lt;/p&gt;
&lt;h2 id="the-solution"&gt;The solution&lt;/h2&gt;
&lt;p&gt;We define a simple wrapper, which chooses the corresponding function depending on the context:&lt;/p&gt;
&lt;pre class="r"&gt;&lt;code&gt;kable_if &amp;lt;- function(x, ...) if (interactive()) print(x, ...) else knitr::kable(x, ...)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Then you simply call it as you would invoke &lt;code&gt;kable&lt;/code&gt; and now you get both, the quick table in the interactive session …&lt;/p&gt;
&lt;p&gt;&lt;img src="https://rpahl.github.io/r-some-blog/posts/kable_if/kable_if.png" width="100%" /&gt;&lt;/p&gt;
&lt;p&gt;… and a formatted table in the report.&lt;/p&gt;
&lt;pre class="r"&gt;&lt;code&gt;kable_if(head(airquality), caption = &amp;quot;New York Air Quality Measurements.&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;table&gt;
&lt;caption&gt;(#tab:unnamed-chunk-9)New York Air Quality Measurements.&lt;/caption&gt;
&lt;thead&gt;
&lt;tr class="header"&gt;
&lt;th align="right"&gt;Ozone&lt;/th&gt;
&lt;th align="right"&gt;Solar.R&lt;/th&gt;
&lt;th align="right"&gt;Wind&lt;/th&gt;
&lt;th align="right"&gt;Temp&lt;/th&gt;
&lt;th align="right"&gt;Month&lt;/th&gt;
&lt;th align="right"&gt;Day&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr class="odd"&gt;
&lt;td align="right"&gt;41&lt;/td&gt;
&lt;td align="right"&gt;190&lt;/td&gt;
&lt;td align="right"&gt;7.4&lt;/td&gt;
&lt;td align="right"&gt;67&lt;/td&gt;
&lt;td align="right"&gt;5&lt;/td&gt;
&lt;td align="right"&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="even"&gt;
&lt;td align="right"&gt;36&lt;/td&gt;
&lt;td align="right"&gt;118&lt;/td&gt;
&lt;td align="right"&gt;8.0&lt;/td&gt;
&lt;td align="right"&gt;72&lt;/td&gt;
&lt;td align="right"&gt;5&lt;/td&gt;
&lt;td align="right"&gt;2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="odd"&gt;
&lt;td align="right"&gt;12&lt;/td&gt;
&lt;td align="right"&gt;149&lt;/td&gt;
&lt;td align="right"&gt;12.6&lt;/td&gt;
&lt;td align="right"&gt;74&lt;/td&gt;
&lt;td align="right"&gt;5&lt;/td&gt;
&lt;td align="right"&gt;3&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="even"&gt;
&lt;td align="right"&gt;18&lt;/td&gt;
&lt;td align="right"&gt;313&lt;/td&gt;
&lt;td align="right"&gt;11.5&lt;/td&gt;
&lt;td align="right"&gt;62&lt;/td&gt;
&lt;td align="right"&gt;5&lt;/td&gt;
&lt;td align="right"&gt;4&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="odd"&gt;
&lt;td align="right"&gt;NA&lt;/td&gt;
&lt;td align="right"&gt;NA&lt;/td&gt;
&lt;td align="right"&gt;14.3&lt;/td&gt;
&lt;td align="right"&gt;56&lt;/td&gt;
&lt;td align="right"&gt;5&lt;/td&gt;
&lt;td align="right"&gt;5&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="even"&gt;
&lt;td align="right"&gt;28&lt;/td&gt;
&lt;td align="right"&gt;NA&lt;/td&gt;
&lt;td align="right"&gt;14.9&lt;/td&gt;
&lt;td align="right"&gt;66&lt;/td&gt;
&lt;td align="right"&gt;5&lt;/td&gt;
&lt;td align="right"&gt;6&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;That’s it. Simply put this function definition somewhere in the top of your document and enjoy a quick workflow.&lt;/p&gt;
&lt;pre class="r distill-force-highlighting-css"&gt;&lt;code&gt;&lt;/code&gt;&lt;/pre&gt;</description>
      <distill:md5>651e426493aaf9d93be18bcf38d98d26</distill:md5>
      <category>R-Markdown</category>
      <category>knitr</category>
      <category>R-Studio</category>
      <guid>https://rpahl.github.io/r-some-blog/posts/kable_if</guid>
      <pubDate>Sun, 17 Nov 2019 00:00:00 +0000</pubDate>
      <media:content url="https://rpahl.github.io/r-some-blog/posts/kable_if/distill-preview.png" medium="image" type="image/png" width="670" height="468"/>
    </item>
    <item>
      <title>My R Style Guide</title>
      <link>https://rpahl.github.io/r-some-blog/posts/r-style-guide</link>
      <description>
This is my take on an R style guide. As such, this is going to be a longer 
post in the hope that is useful to some people out there.



&lt;p&gt;&lt;img src="https://rpahl.github.io/r-some-blog/posts/r-style-guide/style.png" width="20%" /&gt;&lt;/p&gt;
&lt;h1 id="intro"&gt;Introduction&lt;/h1&gt;
&lt;p&gt;There are universal views about readability due to the way how humans process information or text. For example, consider the following number written in two ways:&lt;/p&gt;
&lt;pre class="r"&gt;&lt;code&gt;823969346
823 969 346&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Certainly the second version, which splits the sequence into groups of numbers, is easier to process by humans, implying that spacing is important especially if abstract information is presented.&lt;/p&gt;
&lt;p&gt;The style guide at hand provides a set of rules designed to achieve readable and maintainable R code. Still, of course, it represents a subjective view (of the author) on how to achieve these goals and does not raise any claims of being complete. Thus, if there are viable alternatives to the presented rules or if they are against the intuition of the user, possibly even resulting in hard-to-read code, it is better to deviate from the rules rather than blindly following them.&lt;/p&gt;
&lt;h1 id="style"&gt;Coding style&lt;/h1&gt;
&lt;h2 id="notation"&gt;Notation and naming&lt;/h2&gt;
&lt;h3 id="file-names"&gt;File names&lt;/h3&gt;
&lt;p&gt;File names end in .R and are meaningful about their content:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Good:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;string-algorithms.R&lt;/li&gt;
&lt;li&gt;utility-functions.R&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Bad:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;foo.R&lt;/li&gt;
&lt;li&gt;foo.Rcode&lt;/li&gt;
&lt;li&gt;stuff.R&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="function-names"&gt;Function names&lt;/h3&gt;
&lt;p&gt;Preferrably function names consist of lowercase words separated by an underscore. Using dot (.) separator is avoided as this confuses with the use of generic (&lt;a href="http://adv-r.had.co.nz/S3.html"&gt;S3&lt;/a&gt;) functions. It also prevents name clashes with existing functions from the standard R packages. Camel-case style is also suitable especially for predicate functions returning a boolean value. Function names ideally start with &lt;em&gt;verbs&lt;/em&gt; and describe what the function does.&lt;/p&gt;
&lt;pre class="r"&gt;&lt;code&gt;# GOOD
create_summary()
calculate_avg_clicks()
find_string()
isOdd()

# BAD
crt_smmry()
find.string()
foo()&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="variable-names"&gt;Variable names&lt;/h3&gt;
&lt;p&gt;Variable names consist of lowercase words separated by an underscore or dot. Camel-case style is also suitable especially for variables representing boolean values. Variable names ideally are attributed &lt;em&gt;nouns&lt;/em&gt; and describe what (state) they store.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Good:&lt;/strong&gt;&lt;/p&gt;
&lt;pre class="r"&gt;&lt;code&gt;summary_tab
selected_timeframe
out.table
hasConverged&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Bad:&lt;/strong&gt;&lt;/p&gt;
&lt;pre class="r"&gt;&lt;code&gt;smrytab
selTF
outtab
hascnvrgd&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Name clashes with existing R base functions must be avoided:&lt;/p&gt;
&lt;pre class="r"&gt;&lt;code&gt;# Very bad:
T &amp;lt;- FALSE
c &amp;lt;- 10
mean &amp;lt;- function(a, b) (a + b) / 2
file.path &amp;lt;- &amp;quot;~/Downloads&amp;quot; # clashes with base::file.path&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Loop variables or function arguments can be just single letters if&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;the naming follows standard conventions&lt;/li&gt;
&lt;li&gt;their meaning is clear&lt;/li&gt;
&lt;li&gt;understanding is preserved&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;otherwise use longer variable names.&lt;/p&gt;
&lt;pre class="r"&gt;&lt;code&gt;# GOOD
for (i in 1:10) print(i)
add &amp;lt;- function(a, b) a + b
rnorm &amp;lt;- function(n, mean = 0, sd = 1)

# BAD
for (unnecessary_long_variable_name in 1:10) {
  print(unnecessary_long_variable_name)
}
add &amp;lt;- function(a1, x7) a1 + x7
rnorm &amp;lt;- function(m, n = 0, o = 1)&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="function-definitions"&gt;Function definitions&lt;/h3&gt;
&lt;p&gt;Function definitions first list arguments without default values, followed by those with default values. In both function definitions and function calls, multiple arguments per line are allowed; line breaks are only allowed between assignments.&lt;/p&gt;
&lt;pre class="r"&gt;&lt;code&gt;# GOOD
rnorm &amp;lt;- function(n, mean=0, sd=1)
pnorm &amp;lt;- function(q, mean=0, sd=1, 
                  lower.tail=TRUE,
                  log.p=FALSE)

# BAD
mean &amp;lt;- function(mean=0, sd=1, n)                   # n should be listed first
pnorm &amp;lt;- function(q, mean=0, sd=1, lower.tail=      # don&amp;#39;t break line here
                  TRUE, log.p=FALSE)&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="function-calls"&gt;Function calls&lt;/h3&gt;
&lt;p&gt;When calling a function, the meaning of the function call and arguments should be clear from the call, that is, usually function arguments beyond the first are explicitly named or at least invoked with a meaningful variable name, for example, identical to the name of the function argument:&lt;/p&gt;
&lt;pre class="r"&gt;&lt;code&gt;# GOOD
rnorm(1, mean=1, sd=2)
identical(1, 1.0)   # no need for explicit naming as meaning of call is clear

mean &amp;lt;- 1
sd &amp;lt;- 2
std.dev &amp;lt;- sd
rnorm(1, mean, sd)
rnorm(1, mean, std.dev)

# BAD
rnorm(1, 1, 1)&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="number-of-function-arguments"&gt;Number of function arguments&lt;/h3&gt;
&lt;p&gt;Try to limit the number of function arguments to around five. No human being is able to remember much more than this. If needed, group semantically similar arguments in lists or (even better) in functions returning a list. If you have a hard time doing this, you should think about how to split up your function as it probably does too many things.&lt;/p&gt;
&lt;pre class="r"&gt;&lt;code&gt;# GOOD
my_plot &amp;lt;- function(x, y, 
                   colors = list(bg = &amp;quot;red&amp;quot;, fg = &amp;quot;green&amp;quot;, line = &amp;quot;black&amp;quot;),
                   linetype = list(main = 1, limit = 2, circle = 3))
{ ... }

# Even better
plot_colors &amp;lt;- function(bg = &amp;quot;red&amp;quot;, fg = &amp;quot;green&amp;quot;, line = &amp;quot;black&amp;quot;) {
    list(bg = bg, fg = fg, line = line)
}

plot_linetypes &amp;lt;- function(main = 1, limit = 2, circle = 3) {
    list(main = main, limit = limit, circle = circle)
}

my_plot &amp;lt;- function(x, y, colors = plot_colors(), 
                    linetype = plot_linetypes()) { ... }


# BAD
my_plot &amp;lt;- function(x, y, 
                   color.bg = &amp;quot;red&amp;quot;, color.fg = &amp;quot;green&amp;quot;, color.line = &amp;quot;black&amp;quot;,
                   linetype.main = 1, linetype.limit = 2, linetype.circle = 3)
{ ... }

# Even worse
my_plot &amp;lt;- function(x, y, cl.bg = &amp;quot;red&amp;quot;, cl.fg = &amp;quot;green&amp;quot;, cl.l = &amp;quot;black&amp;quot;,
                    lt.m = 1, lt.l = 2, lt.c = 3)
{ ... }

# Very bad
my_fit_and_plot &amp;lt;- function(formula, data, sub, w, na.action, method,
                            x, y, cl.bg = &amp;quot;red&amp;quot;, cl.fg = &amp;quot;green&amp;quot;,
                            cl.l = &amp;quot;black&amp;quot;, lt.m = 1, lt.l = 2, lt.c = 3)&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="syntax"&gt;Syntax&lt;/h2&gt;
&lt;h3 id="assignment"&gt;Assignment&lt;/h3&gt;
&lt;p&gt;For assignment, both the arrow &lt;code&gt;&amp;lt;-&lt;/code&gt; and equal sign &lt;code&gt;=&lt;/code&gt; can be used. However, try to be consistent throughout.&lt;/p&gt;
&lt;p&gt;Semicolons should &lt;strong&gt;never&lt;/strong&gt; used.&lt;/p&gt;
&lt;pre class="r"&gt;&lt;code&gt;# BAD
x &amp;lt;- 5; y &amp;lt;- 10; z &amp;lt;- 3  # break into three lines instead&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="spacing-around"&gt;Spacing around …&lt;/h3&gt;
&lt;h4 id="commas"&gt;… commas&lt;/h4&gt;
&lt;p&gt;Place a space after a comma but never before (as in regular English)&lt;/p&gt;
&lt;pre class="r"&gt;&lt;code&gt;# GOOD
v &amp;lt;- c(1, 2, 3)
m[1, 2]

# BAD
v &amp;lt;- c(1,2,3)
m[1 ,2]&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id="operators"&gt;… operators&lt;/h4&gt;
&lt;p&gt;Spaces around infix operators (&lt;code&gt;=&lt;/code&gt;, &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;&amp;lt;-&lt;/code&gt;, etc.) should be done in a way that supports readability, for example, by placing spaces between semantically connected groups. If in doubt, rather use more spaces, except with colons &lt;code&gt;:&lt;/code&gt;, which usually should &lt;strong&gt;not&lt;/strong&gt; be surrounded by spaces.&lt;/p&gt;
&lt;pre class="r"&gt;&lt;code&gt;# GOOD
# Spacing according to semantically connected groups
x &amp;lt;- 1:10
base::get
average &amp;lt;- mean(feet/12 + inches, na.rm=TRUE)

# Using more spaces - also ok
average &amp;lt;- mean(feet / 12 + inches, na.rm = TRUE)&lt;/code&gt;&lt;/pre&gt;
&lt;pre class="r"&gt;&lt;code&gt;# BAD
x &amp;lt;- 1 : 10
base :: get
average&amp;lt;-mean(feet/12+inches,na.rm=TRUE)&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id="parentheses"&gt;… parentheses&lt;/h4&gt;
&lt;p&gt;A space is placed before left parentheses, except in a function call, and after right parentheses. Arithmetic expressions form a special case, in which spaces can be omitted.&lt;/p&gt;
&lt;pre class="r"&gt;&lt;code&gt;# GOOD
if (debug) print(x)
plot(x, y)

# Special case arithmetic expression:
2 + (a+b)/(c+d) + z/(1+a)

# BAD
if(debug)print (x)
plot (x, y)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;No spaces are placed around code in parentheses or square brackets, unless there is a comma:&lt;/p&gt;
&lt;pre class="r"&gt;&lt;code&gt;# GOOD
if (debug) print(x)
diamonds[3, ]
diamonds[, 4]

# BAD
if ( debug ) print( x )
diamonds[ ,4]&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id="curly-braces"&gt;… curly braces&lt;/h4&gt;
&lt;p&gt;An opening curly brace is followed by a new line. A closing curly brace goes on its own line.&lt;/p&gt;
&lt;pre class="r"&gt;&lt;code&gt;# GOOD
for (x in letters[1:10]) {
    print(x)
}

add &amp;lt;- function(x, y) {
    x + y
}

add &amp;lt;- function(x, y)
{
    x + y
}

# BAD
add &amp;lt;- function(x, y) {x + y}&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="indentation"&gt;Indentation&lt;/h3&gt;
&lt;p&gt;Code is indented with &lt;em&gt;ideally four&lt;/em&gt;, but &lt;em&gt;at least two&lt;/em&gt; spaces. Usually using four spaces provides better readability than two spaces especially the longer the indented code-block gets.&lt;/p&gt;
&lt;pre class="r"&gt;&lt;code&gt;# Four-space indent:
for (i in seq_len(10)) {
    if (i %% 2 == 0) {
        print(&amp;quot;even&amp;quot;)
    } else {
        print(&amp;quot;odd&amp;quot;)
    }
}

# The same code-block using two-space indent:
for (i in seq_len(10)) {
  if (i %% 2 == 0) {
    print(&amp;quot;even&amp;quot;)
  } else {
    print(&amp;quot;odd&amp;quot;)
  }
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Extended indentation: when a line break occurs inside parentheses, align the wrapped line with the first character inside the parenthesis:&lt;/p&gt;
&lt;pre class="r"&gt;&lt;code&gt;fibonacci &amp;lt;- c(1, 1, 2, 3, 5,
               8, 13, 21, 34)&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="organization"&gt;Code organization&lt;/h2&gt;
&lt;p&gt;As with a good syntax style, the main goal of good code organization is to provide good readability and understanding of the code, especially for external readers/reviewers. While the following guidelines generally have proven to be effective for this purpose, they harm things if applied the wrong way or in isolation. For example, if the user wants to restricts himself to 50 lines of code for each block (see below), but, instead of proper code-reorganization, achieves this by just deleting all comments in the code block, things probably have gotten worse. Thus, &lt;em&gt;any (re-)organization of code first and foremost must serve the improvement of the readability and understanding of the code&lt;/em&gt;, ideally implemented by the guidelines given in this section.&lt;/p&gt;
&lt;h3 id="line-length"&gt;Line length&lt;/h3&gt;
&lt;p&gt;Ideally, the code does &lt;strong&gt;not&lt;/strong&gt; exceed &lt;em&gt;80 characters per line&lt;/em&gt;. This fits comfortably on a printed page with a reasonably sized font and therefore can be easily processed by a human, which tend to read line by line. Longer comments are simply broken into several lines:&lt;/p&gt;
&lt;pre class="r"&gt;&lt;code&gt;# Here is an example of a longer comment, which is just broken into two lines
# in order to serve the 80 character rule.&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Long variable names can cause problems regarding the 80 characters limit. In such cases, one simple yet effective solution is to use interim results, which are saved in a new meaningful variable name. This at the same time often improves the readability of the code. For example:&lt;/p&gt;
&lt;pre class="r"&gt;&lt;code&gt;# Longer statement
total_cost &amp;lt;- cost.hotel + cost.taxi + cost.lunch + cost.airplane +
    cost.breakfast + cost.dinner + cost.car_rental

# Solution with interim result
cost.travel &amp;lt;- cost.taxi + cost.airplane + cost.car_rental
cost.food &amp;lt;- cost.breakfast + cost.lunch + cost.dinner
total_cost &amp;lt;- cost.travel + cost.food + cost.hotel&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Similarly, four-space indenting in combination with multiple nested code-blocks can cause problems to maintain the 80 character limit and may require to relax this rule in such cases. At the same time, however, multiple nested code-blocks should be avoided in the first place, because with more nesting the code usually gets harder to understand.&lt;/p&gt;
&lt;h3 id="block-length"&gt;Block length&lt;/h3&gt;
&lt;p&gt;Each functionally connected block of code (usually a function block) should &lt;strong&gt;not&lt;/strong&gt; exceed a single screen (about 50 lines of code). This allows the code to be read and understood without having to line-scroll. Exceeding this limit usually is a good indication that some of the code should be encapsulated (refactorized) into a separate unit or function. Doing so, not only improves the readability of the code but also flexibilizes (and thereby simplifies) further code development. In particular, single blocks that are separated by comments, often can be refactorized into functions, named similar to the comment, for example:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Long single-block version:&lt;/strong&gt;&lt;/p&gt;
&lt;pre class="r"&gt;&lt;code&gt;# Sub-block 1: simulate data for some model
x &amp;lt;- 1:100
y &amp;lt;- rnorm(length(x))
.
.
.
longer code block generating some data
.
.
.
data &amp;lt;- ...

# Sub-block 2: plot the resulting data points
ylims &amp;lt;- c(0, 30)
p &amp;lt;- ggplot(data) +
.
.
.
longer code block defining plot object
.
.
.

# Sub-block 3: format results and export to Excel file
outFile &amp;lt;- &amp;quot;output.xlsx&amp;quot;
.
.
export to Excel file
.
.&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The singe-block version may exceed a single page and requires a lot of comments just to separate each step visually, but even with this visual separation, it will be unnecessary difficult for a second person to understand the code, because allthough the code might be entirely sequential, he possibly will end up jumping back and forth within the block to get an understanding of it. In addition, if parts of the block are changed at a later time point, the code can easily get out of sync with the comments.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Refactorized version:&lt;/strong&gt;&lt;/p&gt;
&lt;pre class="r"&gt;&lt;code&gt;# Simulate data, plot it and export it to Excel file
data.sim &amp;lt;- simulate_data(x = 1:100, y = rnorm(length(x)), ...)
plot_simulated_data(data.sim, ylims = c(0, 30), ...)
write_results_into_table(data.sim, outFile=&amp;quot;output.xlsx&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In the refactorized version each sub-block was put into a separate function. In contrast to the single-block version, each of these functions can be re-used, tested and have their own documentation. Since each of such functions encapsulate their own environment, the refactorized design is also less vulnerable to side-effects between blocks. A second person can now read and understand function by function without having to worry about the rest of the block.&lt;/p&gt;
&lt;p&gt;Last but not least, the block comments in the single-block versions could be transformed into function names so that the documentation is now part of the code and as such no longer can get out of sync with it.&lt;/p&gt;
&lt;h3 id="packages-and-namespaces"&gt;Packages and namespaces&lt;/h3&gt;
&lt;p&gt;Whenever the &lt;code&gt;::&lt;/code&gt; operator is used, the namespace of the corresponding package is loaded but not attached to the search path.&lt;/p&gt;
&lt;pre class="r"&gt;&lt;code&gt;tools::file_ext(&amp;quot;test.txt&amp;quot;)     # loads the namespace of the &amp;#39;tools&amp;#39; package,&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;[1] &amp;quot;txt&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;pre class="r"&gt;&lt;code&gt;search()                        # but does not attach it to the search path&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt; [1] &amp;quot;.GlobalEnv&amp;quot;        &amp;quot;package:container&amp;quot; &amp;quot;package:stats&amp;quot;    
 [4] &amp;quot;package:graphics&amp;quot;  &amp;quot;package:grDevices&amp;quot; &amp;quot;package:utils&amp;quot;    
 [7] &amp;quot;package:datasets&amp;quot;  &amp;quot;package:methods&amp;quot;   &amp;quot;Autoloads&amp;quot;        
[10] &amp;quot;package:base&amp;quot;     &lt;/code&gt;&lt;/pre&gt;
&lt;pre class="r"&gt;&lt;code&gt;file_ext(&amp;quot;test.txt&amp;quot;)  # and thus gives error if called without namespace prefix&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;Error in file_ext(&amp;quot;test.txt&amp;quot;): could not find function &amp;quot;file_ext&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;pre class="r"&gt;&lt;code&gt;# base::mean and stats::rnorm work, because base and stats namespaces are
# loaded and attached by default:
mean(rnorm(10))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;[1] -0.3115525&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In contrast, the &lt;code&gt;library&lt;/code&gt; and &lt;code&gt;require&lt;/code&gt; commands both load the package’s namespace but also attach its namespace to the search path, which allows to refer to functions of the package without using the &lt;code&gt;::&lt;/code&gt; operator.&lt;/p&gt;
&lt;pre class="r"&gt;&lt;code&gt;library(tools)                # loads namespace and attaches it to search path
search()&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt; [1] &amp;quot;.GlobalEnv&amp;quot;        &amp;quot;package:tools&amp;quot;     &amp;quot;package:container&amp;quot;
 [4] &amp;quot;package:stats&amp;quot;     &amp;quot;package:graphics&amp;quot;  &amp;quot;package:grDevices&amp;quot;
 [7] &amp;quot;package:utils&amp;quot;     &amp;quot;package:datasets&amp;quot;  &amp;quot;package:methods&amp;quot;  
[10] &amp;quot;Autoloads&amp;quot;         &amp;quot;package:base&amp;quot;     &lt;/code&gt;&lt;/pre&gt;
&lt;pre class="r"&gt;&lt;code&gt;file_ext(&amp;quot;test.txt&amp;quot;)          # now works&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;[1] &amp;quot;txt&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Since a call to a function shall not alter the search path, &lt;code&gt;library&lt;/code&gt; or &lt;code&gt;require&lt;/code&gt; statements are not allowed in functions used in R packages. In contrast, &lt;code&gt;library&lt;/code&gt; statements are suitable for local (data analysis) R scripts especially if a specific function is used frequently. An alternative is to locally re-map a frequently used function:&lt;/p&gt;
&lt;pre class="r"&gt;&lt;code&gt;get_file_extension &amp;lt;- tools::file_ext
get_file_extension(&amp;quot;test.txt&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;[1] &amp;quot;txt&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;pre class="r"&gt;&lt;code&gt;get_file_extension(&amp;quot;test.docx&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;[1] &amp;quot;docx&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;pre class="r"&gt;&lt;code&gt;get_file_extension(&amp;quot;test.xlsx&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;[1] &amp;quot;xlsx&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id="docu"&gt;Code documentation&lt;/h1&gt;
&lt;h2 id="function-headers"&gt;Function headers&lt;/h2&gt;
&lt;p&gt;A function header is placed above any function, unless it is defined inside another function.&lt;/p&gt;
&lt;p&gt;It is recommended to use the &lt;a href="https://cran.r-project.org/web/packages/roxygen2"&gt;roxygen&lt;/a&gt; format, because it&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;promotes a standardized documentation&lt;/li&gt;
&lt;li&gt;allows for automatic creation of a user-documentation from the header&lt;/li&gt;
&lt;li&gt;allows for automatic creation of all namespace definitions of an R-package&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;A function header at least contains the following elements (the corresponding roxygen keyword is listed at the start):&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;span class="citation"&gt;@title&lt;/span&gt;: short sentence of what the function does&lt;/li&gt;
&lt;li&gt;&lt;span class="citation"&gt;@description&lt;/span&gt;: extended description of the function (optionally the &lt;span class="citation"&gt;@details&lt;/span&gt; keyword can be used to describe further details)&lt;/li&gt;
&lt;li&gt;&lt;span class="citation"&gt;@param&lt;/span&gt; (or &lt;span class="citation"&gt;@field&lt;/span&gt; with RefClasses): For each input parameter, a summary of the type of the parameter (e.g., string, numeric vector) and, if not obvious from the name, what the parameter does.&lt;/li&gt;
&lt;li&gt;&lt;span class="citation"&gt;@return&lt;/span&gt;: describes the output from the function, if it returns something.&lt;/li&gt;
&lt;li&gt;&lt;span class="citation"&gt;@examples&lt;/span&gt;: if applicable, examples of function calls are provided. Providing executable R code, which shows how to use the function in practice, is a very important part of the documentation, because people usually look at the examples first. While generally example code should work without errors, for the purpose of illustration, it is often useful to also include code that causes an error. If done, the corresponding place in the code should be marked accordingly (use  with roxygen).&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Example of a roxygen-header:&lt;/p&gt;
&lt;pre class="r"&gt;&lt;code&gt;#&amp;#39; @title String suffix matching
#&amp;#39;
#&amp;#39; @description
#&amp;#39; Determines whether \code{end} is a suffix of string \code{s} (borrowed from
#&amp;#39; Python, where it would read \code{s.endswith(end)})
#&amp;#39;
#&amp;#39; @param s (character) the input character string
#&amp;#39; @param end (character) string to be checked whether it is a suffix of the
#&amp;#39; input string \code{s}.
#&amp;#39; @return \code{TRUE} if \code{end} is a suffix of \code{s} else \code{FALSE}
#&amp;#39;
#&amp;#39; @examples
#&amp;#39; string_ends_with(&amp;quot;Hello World!&amp;quot;, &amp;quot;World!&amp;quot;)   # TRUE
#&amp;#39; string_ends_with(&amp;quot; Hello World!&amp;quot;, &amp;quot;world!&amp;quot;)  # FALSE (case sensitive)
string_ends_with &amp;lt;- function(s, end)
{
    # Implementation ...
}&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="inline-code-comments"&gt;Inline code comments&lt;/h2&gt;
&lt;p&gt;Inline comments should explain the programmer’s intent at a higher level of abstraction than the code, that is, they should provide additional information, which are not obvious from reading the code alone. As such, good comments don’t repeat, summarize or explain the code, unless the code is so complicated that it warrants an explanation, in which case, however, it is often worth to revise the code to make it more readable instead.&lt;/p&gt;
&lt;p&gt;Examples of suitable, informative comments:&lt;/p&gt;
&lt;pre class="r"&gt;&lt;code&gt;# Compare strings pairwise and determine first position of differing characters
splitted_s &amp;lt;- strsplit(s, split = &amp;quot;&amp;quot;)[[1]]
splitted_url &amp;lt;- strsplit(url, split = &amp;quot;&amp;quot;)[[1]][1:nchar(s)]
different &amp;lt;- splitted_s != splitted_url
first_different_position &amp;lt;- which(different)[1]

# Provide index via names as we need them later
names(v) &amp;lt;- seq_along(v)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Bad redundant comments:&lt;/p&gt;
&lt;pre class="r"&gt;&lt;code&gt;v &amp;lt;- 1:10  # initialize vector

# Loop through all numbers in the vector and increment by one
for (i in 1:length(v)) {
    v[i] &amp;lt;- v[i] + 1  # increment number
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;That’s it - happy coding!&lt;/p&gt;
&lt;pre class="r distill-force-highlighting-css"&gt;&lt;code&gt;&lt;/code&gt;&lt;/pre&gt;</description>
      <distill:md5>667f51b4883bdaa0b803da7e539544fb</distill:md5>
      <category>coding style</category>
      <guid>https://rpahl.github.io/r-some-blog/posts/r-style-guide</guid>
      <pubDate>Sat, 16 Nov 2019 00:00:00 +0000</pubDate>
      <media:content url="https://rpahl.github.io/r-some-blog/posts/r-style-guide/distill-preview.png" medium="image" type="image/png" width="258" height="191"/>
    </item>
    <item>
      <title>Readable code with base R (part 1)</title>
      <link>https://rpahl.github.io/r-some-blog/posts/readable-code-part1</link>
      <description>
Producing readable R code is of great importance, especially if there is a 
chance that you will share your code with people other than your future self.
In this series of blog posts, I will present some (often underused) base R 
functions for this purpose.



&lt;p&gt;&lt;img src="https://rpahl.github.io/r-some-blog/posts/readable-code-part1/easy-read.png" width="60%" /&gt;&lt;/p&gt;
&lt;p&gt;In this post, we cover &lt;code&gt;startsWith&lt;/code&gt;, &lt;code&gt;endsWith&lt;/code&gt;, and &lt;code&gt;Filter&lt;/code&gt;.&lt;/p&gt;
&lt;h3 id="startswith-and-endswith-for-string-matching"&gt;&lt;code&gt;startsWith&lt;/code&gt; and &lt;code&gt;endsWith&lt;/code&gt; for string-matching&lt;/h3&gt;
&lt;p&gt;There are special base functions for pre- or postfix matching.&lt;/p&gt;
&lt;pre class="r"&gt;&lt;code&gt;# Basic usage:
w &amp;lt;- &amp;quot;Hello World!&amp;quot;
startsWith(w, &amp;quot;Hell&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;[1] TRUE&lt;/code&gt;&lt;/pre&gt;
&lt;pre class="r"&gt;&lt;code&gt;startsWith(w, &amp;quot;Helo&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;[1] FALSE&lt;/code&gt;&lt;/pre&gt;
&lt;pre class="r"&gt;&lt;code&gt;endsWith(w, &amp;quot;!&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;[1] TRUE&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Of course, it also works with vectors. Can’t remember the exact name of a base function? Try this… ;)&lt;/p&gt;
&lt;pre class="r"&gt;&lt;code&gt;base_funcs &amp;lt;- ls(&amp;quot;package:base&amp;quot;)

base_funcs[startsWith(base_funcs, &amp;quot;row&amp;quot;)]&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt; [1] &amp;quot;row&amp;quot;                    &amp;quot;row.names&amp;quot;             
 [3] &amp;quot;row.names.data.frame&amp;quot;   &amp;quot;row.names.default&amp;quot;     
 [5] &amp;quot;row.names&amp;lt;-&amp;quot;            &amp;quot;row.names&amp;lt;-.data.frame&amp;quot;
 [7] &amp;quot;row.names&amp;lt;-.default&amp;quot;    &amp;quot;rowMeans&amp;quot;              
 [9] &amp;quot;rownames&amp;quot;               &amp;quot;rownames&amp;lt;-&amp;quot;            
[11] &amp;quot;rowsum&amp;quot;                 &amp;quot;rowsum.data.frame&amp;quot;     
[13] &amp;quot;rowsum.default&amp;quot;         &amp;quot;rowSums&amp;quot;               &lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The ‘readable’ property really shines when combined with control-flow.&lt;/p&gt;
&lt;pre class="r"&gt;&lt;code&gt;tell_file_type &amp;lt;- function(fn) {
    # Check different file endings
    if (endsWith(fn, &amp;quot;txt&amp;quot;)) {
        print(&amp;quot;A text file.&amp;quot;)
    }
    if (any(endsWith(fn, c(&amp;quot;xlsx&amp;quot;, &amp;quot;xls&amp;quot;)))) {
        print(&amp;quot;An Excel file.&amp;quot;)
    }
}
tell_file_type(&amp;quot;A.txt&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;[1] &amp;quot;A text file.&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;pre class="r"&gt;&lt;code&gt;tell_file_type(&amp;quot;B.xls&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;[1] &amp;quot;An Excel file.&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The resulting code reads very well.&lt;/p&gt;
&lt;h3 id="filter"&gt;&lt;code&gt;Filter&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;Using another nice base function, &lt;code&gt;Filter&lt;/code&gt;, the above code can be further improved.&lt;/p&gt;
&lt;pre class="r"&gt;&lt;code&gt;get_file_type &amp;lt;- function(fn) {
  file_endings &amp;lt;- c(text=&amp;quot;txt&amp;quot;, Excel=&amp;quot;xls&amp;quot;, Excel=&amp;quot;xlsx&amp;quot;)  
  Filter(file_endings, f = function(x) endsWith(fn, x))
}

get_file_type(&amp;quot;C.xlsx&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt; Excel 
&amp;quot;xlsx&amp;quot; &lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Again, very readable to my eyes. It should be noted that for this particular problem using &lt;code&gt;tools::file_ext&lt;/code&gt; is even more appropriate, but I think the point has been made.&lt;/p&gt;
&lt;p&gt;Last but not least, since &lt;code&gt;Filter&lt;/code&gt; works on lists, you can use it on a &lt;code&gt;data.frame&lt;/code&gt; as well.&lt;/p&gt;
&lt;pre class="r"&gt;&lt;code&gt;dat &amp;lt;- data.frame(A=1:3, B=5:3, L=letters[1:3])
dat&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;  A B L
1 1 5 a
2 2 4 b
3 3 3 c&lt;/code&gt;&lt;/pre&gt;
&lt;pre class="r"&gt;&lt;code&gt;Filter(dat, f = is.numeric)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;  A B
1 1 5
2 2 4
3 3 3&lt;/code&gt;&lt;/pre&gt;
&lt;pre class="r"&gt;&lt;code&gt;Filter(dat, f = Negate(is.numeric))  # or Filter(dat, f = function(x) !is.numeric(x))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;  L
1 a
2 b
3 c&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;That’s it for now - see you in part 2.&lt;/p&gt;
&lt;pre class="r distill-force-highlighting-css"&gt;&lt;code&gt;&lt;/code&gt;&lt;/pre&gt;</description>
      <distill:md5>1ad60155ce7a1713c12ddf0cdac0c449</distill:md5>
      <category>base R</category>
      <category>coding style</category>
      <guid>https://rpahl.github.io/r-some-blog/posts/readable-code-part1</guid>
      <pubDate>Mon, 30 Jul 2018 00:00:00 +0000</pubDate>
      <media:content url="https://rpahl.github.io/r-some-blog/posts/readable-code-part1/distill-preview.png" medium="image" type="image/png" width="569" height="322"/>
    </item>
  </channel>
</rss>
